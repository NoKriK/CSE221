\section{Experiments}

\subsection{CPU, Scheduling, and OS Services}

\subsubsection{Measurement overhead}

As we are microbenchmarking, the overhead of the measurement tools that we
choosed may influence our results. Thus we need to know the cost of reading
the clock and since we are using loops for averaging the results of the tests, we
also need to know the overhead caused by these loops.

\paragraph{Methodology}
We are using the \emph{rdtsc} assembly instruction to do the measurement.
The \emph{rdtsc} instruction allows us to read the \emph{Time Stamp Counter}
which is a 64 bit counter containing the number of cycles elapsed since his
reset.
In terms of implementation, the instruction is integrated in the code using
inline assembly and is called using a function which is inlined to avoid the
overhead of the procedure call and the stack frame creation.
To measure the cost of the reading clock operation, we measured the result between
two calls and repeated the operation 100,000 times.\\

The loop overhead has been measured with 100,000 iterations.

\paragraph{Predictions}
The operations between the two rdtsc call are basicly a copy from the result
which are stored in the eax and edx register to the main memory.
As the cache may be hited, it's basicly two cache write, around 10 cycles, and
the cost of the second rdtsc call.\\

As all optimization are turned off, the cost of a loop iteration is basicly a
load from memory, an incrementation, a store to memory, a comparaison and a
jump.
The cache will probably be hited, thus the cost of memory operations will be low.
The total cost may be around 25 cycles if we count 10 cycles per memory
operation and 1 cycle for operation such as incremention, comparaison and
jump.\\

There is no software overhead in any of these operations.

\paragraph{Results}

\begin{tabular}{| l | l | l | l | l |}
\hline
Operation & Hardware cost & Software cost & Prediction & Measured \\
\hline
Reading the clock & 22 cycles & 0 cycles & 22 cycles & 58.555 cycles \\
\hline
Loop & 25 cycles & 0 cycles & 25 cycles & 14.437 cycles \\
\hline
\end{tabular}
\paragraph{Accuracy of Estimates}
Our estimates are two low for the reading time, due to the cost of the memory write operation which is
higher than excepted.
This hypothesis on the memory write operation cost is due to the fact that on long run,
the result is lowered to aproximatly 30 cycles after 50,000 iterations.
We choosed to report the average of a run which did not show this reduction in
the cost because it seems more accurate (i.e. we will call rdtsc once for each
loop).\\

Our estimates are two high for the loops.
This is propably partly due to the fact that we didn't account with the pipelining
capacity of the processor.

\paragraph{Success of Methodology}
Our result for the reading time are varying but we have an average result. As
the overhead will be accounted only once for many iterations, this will not
cause more problem.\\

The result for loop overhead seems accurate.

\subsubsection{Procedure call overhead}
\paragraph{Methodology}
\paragraph{Predictions}
\paragraph{Results}

\begin{tabular}{| l | l | l | l | l |}
\hline
Operation & Hardware cose & Software cost & Prediction & Measured \\
\hline
\end{tabular}
\paragraph{Accuracy of Estimates}
\paragraph{Success of Methodology}
We defined multiple functions with different number of arguments to test the
cost of a procedure call and the overhead of an argument
A procedure call is composed off :
\begin{enumerate}
\item Pushing the argument on the stack
\item Calling the procedure, that is jumping to the beginning of the procedure
\item Creating a stack frame
\item Destroying the stack fram
\item Restoring the instruction pointer
\end{enumerate}



\paragraph{Results}
\begin{tabular}{| l | l | l | l | l |}
\hline
\# of args & Hardware cost & Software cost & Prediction & Measured \\ \hline
0 &   &   &   & 14.443 cycles \\ \hline
1 &   &   &   & 14.440 cycles \\ \hline
2 &   &   &   & 13.782 cycles \\ \hline
3 &   &   &   & 14.439 cycles \\ \hline
4 &   &   &   & 18.565 cycles \\ \hline
5 &   &   &   & 16.502 cycles \\ \hline
6 &   &   &   & 18.604 cycles \\ \hline
7 &   &   &   & 20.627 cycles \\ \hline
\end{tabular} \\
\includegraphics{procCallImage}
That's not much work and the total cost of a procedure call should be around 15
cycles. Each argument may increase the overhead of 1 of 2 cycles.
The result shows us that the base result for a procedure call is around 15
cycles and that each argument increase the cost by 1 or 2 cycles as excepted.

\subsubsection{System call overhead}
We choosed the getpid() system call to test the overhead for a minimal system
call as it's supposed the least expensive system call.
System call are excepted to be more expensive than simple procedure call as they
produce a context switch.
The result shows that a system call takes around 800 clock cycles to complete.

\subsubsection{Task creation time}
For testing the overhead of creating a new process, we simply called fork(). It turned out that it takes about 750,000 clock cycles for creating it without caching and less than 500,000 with caching.While for the overhead of creating a new thread, we simply called pthread\_creat(). It turned out that it takes about 2000,000 clock cycles for creating it without caching and less than 80,000 with caching.
The fact thread creation without caching is taking way longer time than the one for process creation doesn't really make sense to us right now, and we will look into that later as the project goes. But considering that thread creation does't envolve memory alloction, the average case for thread creation is generally faster then the one for process creation.


\subsubsection{Context switch time}
We measured the context switching overhead for both processes and threads. The way we define context switching is by creating a child process/thread and make the child do some task and return back to the parent. The overhead of such context switching is going to be the time start from the creation of the child to the time execution gets back to the parent process/thread excluding the time for child to execute. We only tested the context switching within 2 different processes.
//***TODO actual result

\input{ram}

