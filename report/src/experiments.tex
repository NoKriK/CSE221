\section{Experiments}

\subsection{CPU, Scheduling, and OS Services}

\subsubsection{Measurement overhead}

Reading time of the clock
\paragraph{Methodology}
\paragraph{Predictions}
\paragraph{Results}

\begin{tabular}{| l | l | l | l | l |}
\hline
Operation & Hardware cose & Software cost & Prediction & Measured \\
\hline
\end{tabular}
\paragraph{Accuracy of Estimates}
\paragraph{Success of Methodology}
We are using the \emph{rdtsc} assembly instruction to do the measurement.
The \emph{rdtsc} instruction allows us to read the \emph{Time Stamp Counter}
which is a 64 bit counter containing the number of cycles elapsed since his
reset.
In terms of implementation, the instruction is integrated in the code using
inline assembly and is called using a function which is inlined to avoid the
overhead of the procedure call and the stack frame creation.

According to our measurement, between two call to our inlined rdtsc() function,
there are 60 clock cycle consumed.

\paragraph{Loop overhead}
Since we are using loops for averaging the running time for large scale of tests, the overhead of loop condition is quite important as well. It turns out the overhead it takes for a loop condition is about the same(15 clock cycles) as the overhead for read time rdtsc()(16 clock cycles).

\subsubsection{Procedure call overhead}
We defined multiple functions with different number of arguments to test the
cost of a procedure call and the overhead of an argument
A procedure call is composed off :
\begin{enumerate}
\item Pushing the argument on the stack
\item Calling the procedure, that is jumping to the beginning of the procedure
\item Creating a stack frame
\item Destroying the stack fram
\item Restoring the instruction pointer
\end{enumerate}



\paragraph{Results}
\begin{tabular}{| l | l | l | l | l |}
\hline
\# of args & Hardware cost & Software cost & Prediction & Measured \\ \hline
0 &   &   &   & 14.443 cycles \\ \hline
1 &   &   &   & 14.440 cycles \\ \hline
2 &   &   &   & 13.782 cycles \\ \hline
3 &   &   &   & 14.439 cycles \\ \hline
4 &   &   &   & 18.565 cycles \\ \hline
5 &   &   &   & 16.502 cycles \\ \hline
6 &   &   &   & 18.604 cycles \\ \hline
7 &   &   &   & 20.627 cycles \\ \hline
\end{tabular} \\
\includegraphics{procCallImage}
That's not much work and the total cost of a procedure call should be around 15
cycles. Each argument may increase the overhead of 1 of 2 cycles.
The result shows us that the base result for a procedure call is around 15
cycles and that each argument increase the cost by 1 or 2 cycles as excepted.

\subsubsection{System call overhead}
We choosed the getpid() system call to test the overhead for a minimal system
call as it's supposed the least expensive system call.
System call are excepted to be more expensive than simple procedure call as they
produce a context switch.
The result shows that a system call takes around 800 clock cycles to complete.

\subsubsection{Task creation time}
For testing the overhead of creating a new process, we simply called fork(). It turned out that it takes about 750,000 clock cycles for creating it without caching and less than 500,000 with caching.While for the overhead of creating a new thread, we simply called pthread\_creat(). It turned out that it takes about 2000,000 clock cycles for creating it without caching and less than 80,000 with caching.
The fact thread creation without caching is taking way longer time than the one for process creation doesn't really make sense to us right now, and we will look into that later as the project goes. But considering that thread creation does't envolve memory alloction, the average case for thread creation is generally faster then the one for process creation.


\subsubsection{Context switch time}
We measured the context switching overhead for both processes and threads. The way we define context switching is by creating a child process/thread and make the child do some task and return back to the parent. The overhead of such context switching is going to be the time start from the creation of the child to the time execution gets back to the parent process/thread excluding the time for child to execute. We only tested the context switching within 2 different processes.
//***TODO actual result

\input{ram}

